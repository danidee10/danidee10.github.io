---
layout: post
title: 'Realtime Django Part 3: Building a Chat application RabbitMQ and uWSGI websockets (Building the API)'
date: 2018-01-07T20:45:12+07:00
---

From the last part, we built the authentication system. In this part we're going to dive into the main part of our chat application and actually make it functional. At the end of this part, we should have a functional chat app where users can chat with themselves and invite other friends over.

Let's go!

### Workflow and Architecture
Before we start, let's discuss how everything works from a higher level


If you're worried about having an extra node server. You don't have to because you just have to build your app with `webpack` when you're ready to deploy and you can serve if from `django`, `Nginx`, `Apache` even github pages.

The `npm run dev` command actually runs this:

{% highlight bash %}
webpack-dev-server --inline --progress --config build/webpack.dev.conf.js
{% endhighlight %}

The `--inline` option injects the generated static files into our `index.html` page.

### Implementation

Our goal in this part is to implement the django `API` so we can start new sessions, join sessions and send messages.

Let's start a new django app called `chat`

{% highlight bash %}
python manage.py startapp chat
{% endhighlight %}

Make sure you add the new app to your application's settings before you proceed.

Next we're going to create models that'll hold the data for the messages, chat sessions and the associated users. Let's create some new models in `models.py`.

{% highlight python %}
"""Models for the chat app."""

from uuid import uuid4

from django.db import models
from django.contrib.auth import get_user_model


User = get_user_model()


def deserialize_user(user):
    """Deserialize user instance to JSON."""
    return {
        'id': user.id, 'username': user.username, 'email': user.email,
        'first_name': user.first_name, 'last_name': user.last_name
    }


class TrackableDateModel(models.Model):
    """Abstract model to Track the creation/updated date for a model."""

    create_date = models.DateTimeField(auto_now_add=True)
    update_date = models.DateTimeField(auto_now=True)

    class Meta:
        abstract = True


def _generate_unique_uri():
    """Generates a unique uri for the chat session."""
    return str(uuid4()).replace('-', '')[:15]


class ChatSession(TrackableDateModel):
    """
    A Chat Session.
    
    The uri's are generated by taking the first 15 characters from a UUID
    """

    owner = models.ForeignKey(User, on_delete=models.PROTECT)
    uri = models.URLField(default=_generate_unique_uri)


class ChatSessionMessage(TrackableDateModel):
    """Store messages for a session."""

    user = models.ForeignKey(User, on_delete=models.PROTECT)
    chat_session = models.ForeignKey(
        ChatSession, related_name='messages', on_delete=models.PROTECT
    )
    message = models.TextField(max_length=2000)

    def to_json(self):
        """deserialize message to JSON."""
        return {'user': deserialize_user(self.user), 'message': self.message}


class ChatSessionMember(TrackableDateModel):
    """Store all users in a chat session."""

    chat_session = models.ForeignKey(
        ChatSession, related_name='members', on_delete=models.PROTECT
    )
    user = models.ForeignKey(User, on_delete=models.PROTECT)
{% endhighlight %}

Make sure you run the migrations before proceeding so the database tables can be created.

The next step is to create views (API endpoints) that would be used by our Vue app to manipulate data on the server.

We can easily make use of django rest framework to create them (We won't make use of serializers since our models are pretty simple). Let's do that now in `views.py`

{% highlight python %}
"""Views for the chat app."""

from django.contrib.auth import get_user_model
from .models import (
    ChatSession, ChatSessionMember, ChatSessionMessage, deserialize_user
)

from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework import permissions


class ChatSessionView(APIView):
    """Manage Chat sessions."""

    permission_classes = (permissions.IsAuthenticated,)

    def post(self, request, *args, **kwargs):
        """create a new chat session."""
        user = request.user

        chat_session = ChatSession.objects.create(owner=user)

        return Response({
            'status': 'SUCCESS', 'uri': chat_session.uri,
            'message': 'New chat session created'
        })

    def patch(self, request, *args, **kwargs):
        """Add a user to a chat session."""
        User = get_user_model()

        uri = kwargs['uri']
        username = request.data['username']
        user = User.objects.get(username=username)

        chat_session = ChatSession.objects.get(uri=uri)
        owner = chat_session.owner

        if owner != user:  # Only allow non owners join the room
            chat_session.members.get_or_create(
                user=user, chat_session=chat_session
            )

        owner = deserialize_user(owner)
        members = [
            deserialize_user(chat_session.user) 
            for chat_session in chat_session.members.all()
        ]
        members.insert(0, owner)  # Make the owner the first member

        return Response ({
            'status': 'SUCCESS', 'members': members,
            'message': '%s joined that chat' % user.username,
            'user': deserialize_user(user)
        })
    

class ChatSessionMessageView(APIView):
    """Create/Get Chat session messages."""

    permission_classes = (permissions.IsAuthenticated,)

    def get(self, request, *args, **kwargs):
        """return all messages in a chat session."""
        uri = kwargs['uri']

        chat_session = ChatSession.objects.get(uri=uri)
        messages = [chat_session_message.to_json() 
            for chat_session_message in chat_session.messages.all()]

        return Response({
            'id': chat_session.id, 'uri': chat_session.uri,
            'messages': messages
        })

    def post(self, request, *args, **kwargs):
        """create a new message in a chat session."""
        uri = kwargs['uri']
        message = request.data['message']

        user = request.user
        chat_session = ChatSession.objects.get(uri=uri)

        ChatSessionMessage.objects.create(
            user=user, chat_session=chat_session, message=message
        )

        return Response ({
            'status': 'SUCCESS', 'uri': chat_session.uri, 'message': message,
            'user': deserialize_user(user)
        })
{% endhighlight %}

The `patch` method for the `ChatSessionView` is idempotent because making an HTTP `PATCH` request to it multiples times gives us the same outcome. That means a user can join a chat room several times but there's only going to be one instance of that user in the response (and also in our database table).

Another thing to note about the patch method is that it returns the owner of the chat room as a member but in our database we never add the owner as a member of the room, we just retrieve his information and insert it into the list that's returned back to the client. There's no point duplicating information and having the owner as a member in the database.

We could have easily gotten the user in the `patch` method by calling `request.user` instead we got the username from the client and used that to get the user. This causes an extra database `SELECT` but why did we do that?

Let me give you a simple scenario, what happens if we decide to invite our friends by username to a chat session. With `request.user` we wouldn't be able to do that because `request.user` would refer to the current authenticated user making the request which is us. But by using usernames to join chat sessions it's a piece of cake we just need to post the username to server and it'll know how to get the user and add them to the chat room.

If you decide to have the functionality of adding multiple users at once, you can modify the code to read a list of usernames and fetch them in one go from the database. It's up to you

The main thing you need to have at the back of your mind is to make your code extensible in future.

in the `uris.py` file include this:

{% highlight python %}
"""URL's for the chat app."""

from django.contrib import admin
from django.urls import path

from . import views

urlpatterns = [
    path('chats/', views.ChatSessionView.as_view()),
    path('chats/<uri>/', views.ChatSessionView.as_view()),
    path('chats/<uri>/messages/', views.ChatSessionMessageView.as_view()),
]
{% endhighlight %}

In the main app `uris.py` don't forget to include the URL's for the chat app

{% highlight python %}
from django.contrib import admin
from django.uris import path, include

uripatterns = [
    path('admin/', admin.site.uris),

    # Custom URL's
    path('auth/', include('djoser.uris')),
    path('auth/', include('djoser.uris.authtoken')),
    path('api/', include('chat.uris'))
]
{% endhighlight %}

Our endpoints are ready and now and any **AUTHENTICATED** user can create/join a chat session and they can also post new messages and retrieve messages from a chat session.

Let's try it out:

{% highlight bash %}
$ curl -X POST http://127.0.0.1:8000/auth/token/create/ --data 'username=danidee&password=mypassword'
{"auth_token":"169fcd5067cc55c500f576502637281fa367b3a6"}

$ curl -X POST http://127.0.0.1:8000/api/chats/ -H 'Authorization: Token 169fcd5067cc55c500f576502637281fa367b3a6'
{"status":"SUCCESS","uri":"040213b14a02451","message":"New chat session created"}

$ curl -X POST http://127.0.0.1:8000/auth/users/create/ --data 'username=daniel&password=mypassword'
{"email":"","username":"daniel","id":2}

$ curl -X POST http://127.0.0.1:8000/auth/token/create/ --data 'username=daniel&password=mypassword'
{"auth_token":"9c3ea2d194d7236ac68d2faefba017c8426a8484"}

$ curl -X PATCH http://127.0.0.1:8000/api/chats/040213b14a02451/ --data 'username=daniel' -H 'Authorization: Token 9c3ea2d194d7236ac68d2faefba017c8426a8484'
{"status":"SUCCESS","members":[{"id":1,"username":"danidee","email":"osaetindaniel@gmail.com","first_name":"","last_name":""},{"id":2,"username":"daniel","email":"","first_name":"","last_name":""}],"message":"daniel joined that chat","user":{"id":2,"username":"daniel","email":"","first_name":"","last_name":""}}
{% endhighlight %}

Let's send some messages

{% highlight python %}
$ curl -X POST http://127.0.0.1:8000/api/chats/040213b14a02451/messages/ --data 'message=Hello!' -H 'Authorization: Token 169fcd5067cc55c500f576502637281fa367b3a6'
{"status":"SUCCESS","uri":"040213b14a02451","message":"Hello!","user":{"id":1,"username":"danidee","email":"osaetindaniel@gmail.com","first_name":"","last_name":""}}

$ curl -X POST http://127.0.0.1:8000/api/chats/040213b14a02451/messages/ --data 'message=Hey whatsup!' -H 'Authorization: Token 9c3ea2d194d7236ac68d2faefba017c8426a8484'
{"status":"SUCCESS","uri":"040213b14a02451","message":"Hey whatsup! i dey","user":{"id":2,"username":"daniel","email":"","first_name":"","last_name":""}}
{% endhighlight %}

Let's request for the messages history

{% highlight python %}
$ curl http://127.0.0.1:8000/api/chats/040213b14a02451/messages/ -H 'Authorization: Token 169fcd5067cc55c500f576502637281fa367b3a6'
{"id":1,"uri":"040213b14a02451","messages":[{"user":{"id":1,"username":"danidee","email":"osaetindaniel@gmail.com","first_name":"","last_name":""},"message":"Hello!"},{"user":{"id":2,"username":"daniel","email":"","first_name":"","last_name":""},"message":"Hey whatsup!"}]}
{% endhighlight %}

Congrats! if you made it this far, you've succesfully built an API that allows users to communicate with each other by starting chat sessions and inviting other users to join the session.

That's about all there is to this part, In the next part, we're going to plug our Vue frontend into this `API`.

I hope you're enjoying this article as much as i did while writing it.